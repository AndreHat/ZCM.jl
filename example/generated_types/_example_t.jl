# THIS IS AN AUTOMATICALLY GENERATED FILE.
# DO NOT MODIFY BY HAND!!
#
# Generated by zcm-gen
#

# This file intended to be imported by user
# after setting up their LOAD_PATH,
# but you must import the type directly into the user's module:
#     pushfirst!(LOAD_PATH, "path/to/dir/containing/this/file")
#     import _example_t : example_t
module _example_t
__basemodule = parentmodule(_example_t)
__basemodule == _example_t && (__basemodule = Main)

import ZCM

function __init__()
end

export example_t
mutable struct example_t <: ZCM.AbstractZcmType

    # **********************
    # Members
    # **********************

    timestamp                     ::Int64
    position                      ::Array{Float64,1}
    orientation                   ::Array{Float64,1}
    num_ranges                    ::Int32
    ranges                        ::Array{Int16,1}
    name                          ::String
    enabled                       ::Bool
    nExamples1                    ::Int32
    nExamples2                    ::Int32
    subExamples                   ::Array{ZCM.AbstractZcmType,2} # example_t
    subStrings                    ::Array{String,2}


    # **********************
    # Constants
    # **********************

    test_const_8_max_hex          ::Int8
    test_const_16_max_hex         ::Int16
    test_const_32_max_hex         ::Int32
    test_const_64_max_hex         ::Int64
    test_const_float              ::Float32
    test_const_double             ::Float64


    function example_t()

        self = new()

        # **********************
        # Members
        # **********************

        self.timestamp = 0
        self.position = [ 0.0 for dim0=1:3 ]
        self.orientation = [ 0.0 for dim0=1:4 ]
        self.num_ranges = 0
        self.ranges = [ 0 for dim0=1:self.num_ranges ]
        self.name = ""
        self.enabled = false
        self.nExamples1 = 0
        self.nExamples2 = 0
        self.subExamples = [ __basemodule._example_t.example_t() for dim0=1:self.nExamples1, dim1=1:self.nExamples2 ]
        self.subStrings = [ "" for dim0=1:self.nExamples1, dim1=1:self.nExamples2 ]

        # **********************
        # Constants
        # **********************

        self.test_const_8_max_hex::Int8 = reinterpret(Int8,0xff)
        self.test_const_16_max_hex::Int16 = reinterpret(Int16,0xffff)
        self.test_const_32_max_hex::Int32 = reinterpret(Int32,0xffffffff)
        self.test_const_64_max_hex::Int64 = reinterpret(Int64,0xffffffffffffffff)
        self.test_const_float::Float32 = 1e-20
        self.test_const_double::Float64 = 12.1e200

        return self
    end

end

const __example_t_hash = Ref(Int64(0))
function ZCM._get_hash_recursive(::Type{example_t}, parents::Array{String})
    if __example_t_hash[] != 0; return __example_t_hash[]; end
    if "example_t" in parents; return 0; end
    newparents::Array{String} = [parents[:]; "example_t"::String];
    hash::UInt64 = 0x176a67702efc53df + reinterpret(UInt64, ZCM._get_hash_recursive(__basemodule._example_t.example_t, newparents))
    hash = (hash << 1) + ((hash >>> 63) & 0x01)
    __example_t_hash[] = reinterpret(Int64, hash)
    return __example_t_hash[]
end

function ZCM.getHash(::Type{example_t})
    return ZCM._get_hash_recursive(example_t, Array{String,1}())
end

function ZCM._encode_one(msg::example_t, buf)
    write(buf, hton(msg.timestamp))
    @assert size(msg.position,1)==3 "Msg of type `example_t` requires field `position` dimension `1` to be size `3`"
    for i0=1:3
        write(buf, hton(msg.position[i0]))
    end
    @assert size(msg.orientation,1)==4 "Msg of type `example_t` requires field `orientation` dimension `1` to be size `4`"
    for i0=1:4
        write(buf, hton(msg.orientation[i0]))
    end
    write(buf, hton(msg.num_ranges))
    @assert size(msg.ranges,1)==msg.num_ranges "Msg of type `example_t` requires field `ranges` dimension `1` to be size `msg.num_ranges`"
    for i0=1:msg.num_ranges
        write(buf, hton(msg.ranges[i0]))
    end
    write(buf, hton(UInt32(length(msg.name) + 1)))
    write(buf, msg.name)
    write(buf, UInt8(0))
    write(buf, msg.enabled)
    write(buf, hton(msg.nExamples1))
    write(buf, hton(msg.nExamples2))
    @assert size(msg.subExamples,1)==msg.nExamples1 "Msg of type `example_t` requires field `subExamples` dimension `1` to be size `msg.nExamples1`"
    @assert size(msg.subExamples,2)==msg.nExamples2 "Msg of type `example_t` requires field `subExamples` dimension `2` to be size `msg.nExamples2`"
    for i0=1:msg.nExamples1
        for i1=1:msg.nExamples2
            @assert isa(msg.subExamples[i0,i1], __basemodule._example_t.example_t) "Msg of type `example_t` requires field `msg.subExamples[i0,i1]` to be of type `example_t`"
            ZCM._encode_one(msg.subExamples[i0,i1],buf)
        end
    end
    @assert size(msg.subStrings,1)==msg.nExamples1 "Msg of type `example_t` requires field `subStrings` dimension `1` to be size `msg.nExamples1`"
    @assert size(msg.subStrings,2)==msg.nExamples2 "Msg of type `example_t` requires field `subStrings` dimension `2` to be size `msg.nExamples2`"
    for i0=1:msg.nExamples1
        for i1=1:msg.nExamples2
            write(buf, hton(UInt32(length(msg.subStrings[i0,i1]) + 1)))
            write(buf, msg.subStrings[i0,i1])
            write(buf, UInt8(0))
        end
    end
end

function ZCM.encode(msg::example_t)
    buf = IOBuffer()
    write(buf, hton(ZCM.getHash(example_t)))
    ZCM._encode_one(msg, buf)
    return ZCM._takebuf_array(buf);
end

function ZCM._decode_one(::Type{example_t}, buf)
    msg = example_t();
    msg.timestamp = ntoh(reinterpret(Int64, read(buf, 8))[1])
    msg.position = Array{Float64, 1}(undef,3)
    for i0=1:3
        msg.position[i0] = ntoh(reinterpret(Float64, read(buf, 8))[1])
    end
    msg.orientation = Array{Float64, 1}(undef,4)
    for i0=1:4
        msg.orientation[i0] = ntoh(reinterpret(Float64, read(buf, 8))[1])
    end
    msg.num_ranges = ntoh(reinterpret(Int32, read(buf, 4))[1])
    msg.ranges = Array{Int16, 1}(undef,msg.num_ranges)
    for i0=1:msg.num_ranges
        msg.ranges[i0] = ntoh(reinterpret(Int16, read(buf, 2))[1])
    end
    msg.name = String(read(buf, ntoh(reinterpret(UInt32, read(buf, 4))[1])))[1:end-1]
    msg.enabled = reinterpret(Bool, read(buf, 1))[1]
    msg.nExamples1 = ntoh(reinterpret(Int32, read(buf, 4))[1])
    msg.nExamples2 = ntoh(reinterpret(Int32, read(buf, 4))[1])
    msg.subExamples = Array{ZCM.AbstractZcmType, 2}(undef,msg.nExamples1,msg.nExamples2)
    for i0=1:msg.nExamples1
        for i1=1:msg.nExamples2
            msg.subExamples[i0,i1] = ZCM._decode_one(__basemodule._example_t.example_t,buf)
        end
    end
    msg.subStrings = Array{String, 2}(undef,msg.nExamples1,msg.nExamples2)
    for i0=1:msg.nExamples1
        for i1=1:msg.nExamples2
            msg.subStrings[i0,i1] = String(read(buf, ntoh(reinterpret(UInt32, read(buf, 4))[1])))[1:end-1]
        end
    end
    return msg
end

function ZCM.decode(::Type{example_t}, data::Vector{UInt8})
    buf = IOBuffer(data)
    if ntoh(reinterpret(Int64, read(buf, 8))[1]) != ZCM.getHash(example_t)
        throw("Decode error")
    end
    return ZCM._decode_one(example_t, buf)
end

end # `module _example_t` block
