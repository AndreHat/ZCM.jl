# THIS IS AN AUTOMATICALLY GENERATED FILE.
# DO NOT MODIFY BY HAND!!
#
# Generated by zcm-gen
#

# This file intended to be imported by user
# after setting up their LOAD_PATH,
# but you must import the type directly into the user's module:
#     unshift!(LOAD_PATH, "path/to/dir/containing/this/file")
#     import _example2_t : example2_t
module _example2_t
__basemodule = parentmodule(_example2_t)

import ZCM

function __init__()
end

export example2_t
mutable struct  example2_t <: ZCM.AbstractZcmType

    # **********************
    # Members
    # **********************

    timestamp2                    ::Int64
    position2                     ::Array{Float64,1}
    orientation2                  ::Array{Float64,1}
    num_ranges2                   ::Int32
    ranges2                       ::Array{Int16,1}
    name2                         ::String
    enabled2                      ::Bool


    function example2_t()

        self = new()

        # **********************
        # Members
        # **********************

        self.timestamp2 = 0
        self.position2 = [ 0.0 for dim0=1:3 ]
        self.orientation2 = [ 0.0 for dim0=1:4 ]
        self.num_ranges2 = 0
        self.ranges2 = [ 0 for dim0=1:self.num_ranges2 ]
        self.name2 = ""
        self.enabled2 = false

        return self
    end

end

const __example2_t_hash = Ref(Int64(0))
function ZCM._get_hash_recursive(::Type{example2_t}, parents::Array{String})
    if __example2_t_hash[] != 0; return __example2_t_hash[]; end
    if "example2_t" in parents; return 0; end
    hash::UInt64 = 0x2caa13979d1b6e97
    hash = (hash << 1) + ((hash >>> 63) & 0x01)
    __example2_t_hash[] = reinterpret(Int64, hash)
    return __example2_t_hash[]
end

function ZCM.getHash(::Type{example2_t})
    return ZCM._get_hash_recursive(example2_t, Array{String,1}())
end

function ZCM._encode_one(msg::example2_t, buf)
    write(buf, hton(msg.timestamp2))
    @assert size(msg.position2,1)==3 "Msg of type `example2_t` requires field `position2` dimension `1` to be size `3`"
    for i0=1:3
        write(buf, hton(msg.position2[i0]))
    end
    @assert size(msg.orientation2,1)==4 "Msg of type `example2_t` requires field `orientation2` dimension `1` to be size `4`"
    for i0=1:4
        write(buf, hton(msg.orientation2[i0]))
    end
    write(buf, hton(msg.num_ranges2))
    @assert size(msg.ranges2,1)==msg.num_ranges2 "Msg of type `example2_t` requires field `ranges2` dimension `1` to be size `msg.num_ranges2`"
    for i0=1:msg.num_ranges2
        write(buf, hton(msg.ranges2[i0]))
    end
    write(buf, hton(UInt32(length(msg.name2) + 1)))
    write(buf, msg.name2)
    write(buf, UInt8(0))
    write(buf, msg.enabled2)
end

function ZCM.encode(msg::example2_t)
    buf = IOBuffer()
    write(buf, hton(ZCM.getHash(example2_t)))
    ZCM._encode_one(msg, buf)
    return ZCM._takebuf_array(buf);
end

function ZCM._decode_one(::Type{example2_t}, buf)
    msg = example2_t();
    msg.timestamp2 = ntoh(reinterpret(Int64, read(buf, 8))[1])
    msg.position2 = Array{Float64, 1}(undef,3)
    for i0=1:3
        msg.position2[i0] = ntoh(reinterpret(Float64, read(buf, 8))[1])
    end
    msg.orientation2 = Array{Float64, 1}(undef,4)
    for i0=1:4
        msg.orientation2[i0] = ntoh(reinterpret(Float64, read(buf, 8))[1])
    end
    msg.num_ranges2 = ntoh(reinterpret(Int32, read(buf, 4))[1])
    msg.ranges2 = Array{Int16, 1}(undef,msg.num_ranges2)
    for i0=1:msg.num_ranges2
        msg.ranges2[i0] = ntoh(reinterpret(Int16, read(buf, 2))[1])
    end
    msg.name2 = String(read(buf, ntoh(reinterpret(UInt32, read(buf, 4))[1])))[1:end-1]
    msg.enabled2 = reinterpret(Bool, read(buf, 1))[1]
    return msg
end

function ZCM.decode(::Type{example2_t}, data::Vector{UInt8})
    buf = IOBuffer(data)
    if ntoh(reinterpret(Int64, read(buf, 8))[1]) != ZCM.getHash(example2_t)
        throw("Decode error")
    end
    return ZCM._decode_one(example2_t, buf)
end

end # `module _example2_t` block
